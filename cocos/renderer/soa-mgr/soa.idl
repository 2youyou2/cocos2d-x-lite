[Prefix="CC::"]
interface Vec3{
    void Vec3();
    void Vec3(float _x,float _y ,float _z);
    void Vec3([Const,Ref] Vec3 _v3);
    void set(float _x,float _y,float _z);
    void print();
 //   [Operator="="] void eq([Const,Ref] Vec3 _v3);
    attribute float x;
    attribute float y;
    attribute float z;
};

[Prefix="CC::"]
interface Quat{
    void Quat();
    void Quat(float _w,float _x,float _y,float _z);
    void set(float _w,float _x,float _y,float _z);
    attribute float x;
    attribute float y;
    attribute float z;
    attribute float w;
};

[Prefix="CC::"]
interface Mat4{
    void Mat4();
    attribute float [] m;
    void recompose([Const,Ref] Vec3 t, [Const,Ref] Quat r, [Const,Ref] Vec3 s);
	[Const] void decompose([Ref] Vec3 t, [Ref] Quat r,[Ref] Vec3 s);
};

[Prefix="CC::"]
interface Transform {
    void Transform();

    Transform getParent();
	void setParent(Transform parent);

    [Value] Vec3 getPosition();
	void setPosition([Ref] Vec3 vec);

	[Value] Quat getRotation();
	void setRotation([Ref] Quat q);

	[Value] Vec3 getScale();
	void setScale([Ref] Vec3 vec);

	[Value] Vec3 getWorldPosition();
	void setWorldPosition([Ref] Vec3 vec);

	[Value] Quat getWorldRotation();
	void setWorldRotation([Ref] Quat q);

	[Value] Vec3 getWorldScale();
	void setWorldScale([Ref] Vec3 vec);

	[Value] Mat4 getWorldMat();
	void setWorldMat([Ref] Mat4 m);

    void updateForce();

    void printPosition();
};

enum CC_MemMgrType
{
	"CC::MMT_TRANSFORM",
	"CC::MMT_OBJDATA",
	"CC::MMT_COUNT",
};

enum CC_TransformMemType
{
	"CC::SMT_STATIC",
	"CC::SMT_DYNAMIC",
	"CC::SMT_COUNT"
};
/*
[Prefix="CC::"]
interface RebaseListener{
    void RebaseListener();
};

[Prefix="CC::"]
interface TransformSoAManager{
    void TransformSoAManager(CC_TransformMemType type,Transform pDummyTransform, unsigned short depthLevel, unsigned long maxNodeCount, unsigned long cleanupThreshold, RebaseListener pListener);
};

[Prefix="CC::"]
interface SoAMemManager
{
 //   void SoAMemManager();
	void SoAMemManager(CC_TransformMemType type, [Const] unsigned long[] elmMemSizes, [Const] any cleanupRoutines, unsigned long elmMemSizeCount, unsigned short depthLevel, unsigned long maxNodeCount, unsigned long cleanupThreshold, unsigned long maxHardLimit, RebaseListener pListener);
};
*/

[Prefix="CC::"]
interface SceneManager
{
    void SceneManager();

    boolean initialize();
    void destroy();

    void createTransform([Ref] Transform trans, unsigned short depth);
    void destroyTransfrom([Ref] Transform trans, unsigned short depth);

    void nodeMoved([Ref] Transform inOutTransform, unsigned short oldDepth, unsigned short newDepth);
    void updateTransform();

    static void setDebug(boolean val);
};
